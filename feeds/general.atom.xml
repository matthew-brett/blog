<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>The Nipy blog</title><link href="http://matthew-brett.github.io/blog/" rel="alternate"></link><link href="http://matthew-brett.github.io/blog/feeds/general.atom.xml" rel="self"></link><id>http://matthew-brett.github.io/blog/</id><updated>2013-05-26T12:00:00-07:00</updated><entry><title>What a scientist does not need to know about programming</title><link href="http://matthew-brett.github.io/blog/unscientific-programming.html" rel="alternate"></link><updated>2013-05-26T12:00:00-07:00</updated><author><name>Matthew Brett</name></author><id>tag:matthew-brett.github.io/blog,2013-05-26:unscientific-programming.html</id><summary type="html">&lt;p&gt;We various of the Berkeley NIPY crowd were in a Mexican restaurant yesterday
lunchtime. We discussed the IPython notebook and scientific programming and
reproducible research.&lt;/p&gt;
&lt;p&gt;One question struck me as fundamental: &lt;em&gt;do scientists have to learn to be
software engineers?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I think the common answer to this is "No - scientific coding is different".  The
"No" camp points out that scientists use code in a different way to software
engineers.  Science is exploration, and so is scientific coding.  Scientific
code is provisional, often changing.  There is no spec, there is no production
system that must &lt;em&gt;just work&lt;/em&gt;.  We are trying stuff out, seeing what works,
adjusting to our better understanding of the data and the ideas.&lt;/p&gt;
&lt;p&gt;The canonical software engineer runs a web application with some database
behind it.&lt;/p&gt;
&lt;p&gt;Accepting the "No", we look at things that software engineers should learn:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Version control.  Essential for a software engineer, apparently, because
   they need to be able to rollback their changes, and keep track of released
   and development versions.  Desirable maybe for a scientist, but not
   essential, because the code never goes into production, and we always use
   the latest version of the code.&lt;/li&gt;
&lt;li&gt;Testing.  Essential for a software engineer, otherwise they may release
   code that corrupts a database of financial transactions or delivers the
   wrong item to your address.  Desirable maybe for a scientist, but not
   essential because the nature of the code changes so often that it would
   only slow things down to write exhaustive tests, only for the code to
   change track and make the tests obsolete.&lt;/li&gt;
&lt;li&gt;Code review.  Essential for a software engineer, because they work in teams
   with other software engineers.  This is their job, to write code, and they
   can learn from each other. Desirable maybe for a scientist, but not
   essential because each scientist owns their own problem and so only they
   can understand their code.  Explaining the code is time-consuming and slows
   progress in developing new ideas.  Others in the lab are not software
   engineers, so they are not trained to review code, they will not enjoy it
   and they will not do a good job.&lt;/li&gt;
&lt;li&gt;Releases.  Essential for a software engineer because they may be paid to
   provide code that others can use.  The release labels code that can be
   used.  The software engineer can and should make sure the code works as
   advertised.  Desirable maybe for a scientist, but not essential, because
   the code changes often, and the code may be written to solve a very
   specific problem that could not be of much interest to another researcher.
   If the other researcher is interested, they should make the effort to work
   out how to use the code, that is not the job of the author-scientist, they
   are not paid to support software, but to produce science.&lt;/li&gt;
&lt;li&gt;Documentation.  Essential for a software engineer because they want their
   code to be used correctly by other people.  Desirable but not essential for
   the scientist because scientific code is not for distribution except to
   other scientists who must take responsibility for the code themselves.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I think that these set of beliefs lie at the heart of the problem for
reproducible science.&lt;/p&gt;
&lt;p&gt;The job of the software engineer is to write code that other people can use.
The open-source software engineer writes code that others can read and change.&lt;/p&gt;
&lt;!--- vim:ft=markdown --&gt;</summary><category term="Nipy"></category><category term="Nipyworld"></category><category term="Blog"></category><category term="scientific software"></category><category term="software"></category><category term="programming"></category><category term="code"></category></entry><entry><title>Nipy World blog moved from there to here</title><link href="http://matthew-brett.github.io/blog/nipy-moved.html" rel="alternate"></link><updated>2013-05-12T19:42:00-07:00</updated><author><name>Matthew Brett</name></author><id>tag:matthew-brett.github.io/blog,2013-05-12:nipy-moved.html</id><summary type="html">&lt;p&gt;The Nipy World blog used to be on Blogspot at &lt;a href="http://nipyworld.blogspot.com"&gt;http://nipyworld.blogspot.com&lt;/a&gt;.
I'm restarting the blog here because it's easier and more fun to write the blog
using &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt;.  I hope that it will be easier for
my fellow NIPistas to add their own posts using Github.&lt;/p&gt;
&lt;!--- vim:ft=markdown --&gt;</summary><category term="Nipy"></category><category term="Nipyworld"></category><category term="Blog"></category></entry></feed>